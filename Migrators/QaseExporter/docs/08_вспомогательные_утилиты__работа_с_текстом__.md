# Chapter 8: Вспомогательные Утилиты (Работа с текстом)


В [предыдущей главе](07_сервис_записи_результатов_.md) мы узнали, как [Сервис Записи Результатов](07_сервис_записи_результатов_.md) сохраняет все наши подготовленные данные – тест-кейсы, общие шаги и вложения – в файлы на вашем компьютере. Но прежде чем данные будут записаны, их часто нужно немного "причесать", особенно текстовые описания, шаги и другие поля. Именно для этой цели в `QaseExporter` существует набор **Вспомогательных Утилит** для работы с текстом, собранных в статическом классе `Utils`.

Представьте, что вы получили текст из Qase, например, описание шага:

```
**Важно:** Проверьте, что отображается картинка ![Лого](https://example.com/logo.png) и ссылка [на сайт](https://example.com).
```

Этот текст использует разметку, похожую на Markdown: `**текст**` для жирного, `![...](...)` для изображений, `[...] (...)` для ссылок. Наша цель – экспортировать это в формат, который будет корректно отображаться в другой системе, и часто это формат, похожий на HTML. Кроме того, нам нужно извлечь информацию о вложении (картинке) и сохранить ее отдельно.

Вот здесь и приходят на помощь утилиты из `Utils`. Это как набор маленьких инструментов – ножницы, клей, маркеры – которые помогают:

*   Найти и "вырезать" информацию о вложениях из текста.
*   Превратить разметку Qase (жирный, зачеркнутый текст, ссылки) в HTML-теги (`<strong>`, `<s>`, `<a href=...>`).
*   Обработать специальные символы, чтобы они не ломали итоговый формат.

## Что такое `Utils` и как это работает?

`Utils` – это **статический класс**. Это означает, что вам не нужно создавать его экземпляр (как мы делали с `ExportService` или `Client`). Вы просто вызываете его методы напрямую, используя имя класса, вот так: `Utils.КакойТоМетод(текст)`.

Этот класс содержит набор методов, каждый из которых выполняет одну конкретную задачу по преобразованию текста. Основные задачи:

1.  **Извлечение вложений (`ExtractAttachments`):** Находит в тексте ссылки на вложения (например, `![картинка.jpg](URL)`), заменяет их специальным маркером (например, `<<<картинка.jpg>>>`), а информацию об имени и URL картинки возвращает отдельно, чтобы [Сервис Обработки Вложений](06_сервис_обработки_вложений_.md) мог их скачать.
2.  **Преобразование гиперссылок (`ConvertingHyperlinks`):** Находит ссылки вида `[текст ссылки](URL)` и превращает их в HTML-тег `<a>`.
3.  **Преобразование стилей текста:**
    *   `ConvertingToggleStrongStr`: Превращает `**жирный текст**` в `<strong>жирный текст</strong>`.
    *   `ConvertingToggleStrikethroughStr`: Превращает `~~зачеркнутый~~` в `<s>зачеркнутый</s>`.
4.  **Преобразование блоков кода:**
    *   `ConvertingBlockCodeStr`: Превращает многострочные блоки <code>```код```</code> в `<pre><code>код</code></pre>`.
    *   `ConvertingCodeStr`: Превращает встроенный код `` `код` `` в `<code>код</code>`.
5.  **Обработка спецсимволов и форматирования:**
    *   `ConvertingFormatCharacters`: Заменяет символы новой строки (`\n`) на HTML-теги абзацев (`<p>`).
    *   `ConvertingAngleBracketsStr`: Заменяет экранированные угловые скобки (`\<`) на HTML-сущности (`&lt;`), чтобы они отображались как есть, а не как часть HTML-тега.
    *   `RemoveBackslashCharacters`: Удаляет лишние обратные слеши (`\`).

Эти методы часто вызываются цепочкой, один за другим, чтобы последовательно применить все нужные преобразования к тексту.

## Как используются утилиты?

Утилиты из `Utils` используются в разных частях `QaseExporter`, там, где нужно обработать текст, полученный из Qase. Особенно активно они применяются в `StepService` (для обработки описаний шагов) и `TestCaseService` (для обработки описаний тест-кейсов).

Давайте посмотрим на пример из `StepService`, который обрабатывает описание шага:

```csharp
// Файл: Services/StepService.cs (фрагмент метода ConvertStep)

private async Task<Step> ConvertStep(QaseStep step, Guid testCaseId)
{
    // 1. Извлекаем вложения из поля Action (Шаг)
    var action = Utils.ExtractAttachments(step.Action);
    // 2. Извлекаем вложения из поля ExpectedResult (Ожидаемый результат)
    var expected = Utils.ExtractAttachments(step.ExpectedResult);
    // 3. Извлекаем вложения из поля Data (Данные)
    var testData = Utils.ExtractAttachments(step.Data);

    // Создаем новый шаг в нашем формате
    var newStep = new Step
    {
        // 4. Применяем цепочку преобразований к тексту шага (Action)
        Action = ConvertingStepDescription(action.Description),
        // 5. Применяем ту же цепочку к ожидаемому результату
        Expected = ConvertingStepDescription(expected.Description),
        // 6. И к тестовым данным
        TestData = ConvertingStepDescription(testData.Description),
        // Инициализируем списки для имен файлов вложений
        ActionAttachments = new List<string>(),
        ExpectedAttachments = new List<string>(),
        TestDataAttachments = new List<string>()
    };

    // ... (дальше код для скачивания и сохранения вложений, используя action.Attachments и т.д.) ...

    return newStep;
}

// Метод, который применяет цепочку преобразований
private static string ConvertingStepDescription(string? description)
{
    if (string.IsNullOrEmpty(description))
    {
        return string.Empty;
    }

    // Вызываем утилиты одну за другой!
    return
        Utils.RemoveBackslashCharacters(          // 9. Удалить лишние '\'
        Utils.ConvertingAngleBracketsStr(         // 8. Заменить \< на &lt;
        Utils.ConvertingToggleStrikethroughStr(   // 7. ~~текст~~ -> <s>текст</s>
        Utils.ConvertingCodeStr(              // 6. `код` -> <code>код</code>
        Utils.ConvertingBlockCodeStr(         // 5. ```код``` -> <pre><code>код</code></pre>
        Utils.ConvertingToggleStrongStr(      // 4. **жирный** -> <strong>жирный</strong>
        Utils.ConvertingHyperlinks(           // 3. [ссылка](url) -> <a href="url">ссылка</a>
        Utils.ConvertingFormatCharacters(     // 2. \n -> <p>...</p>
        Utils.ConvertingFormatCharactersWithBlockCodeStr(description))))))))); // 1. Обработать сначала форматирование вне блоков кода
}
```

Что здесь происходит:

1.  Сначала `Utils.ExtractAttachments` вызывается для каждого текстового поля (`Action`, `Expected`, `Data`). Этот метод находит все картинки типа `![...](...)`, заменяет их на `<<<имя_файла>>>` в тексте и возвращает объект `QaseDescriptionData`, который содержит измененное описание (`Description`) и список найденных вложений (`Attachments`).
2.  Затем вызывается метод `ConvertingStepDescription`, который применяет целую **цепочку** вызовов `Utils` к описанию, полученному на шаге 1.
3.  Эта цепочка важна: сначала обрабатывается общее форматирование (`ConvertingFormatCharacters...`), потом ссылки (`ConvertingHyperlinks`), потом стили текста (`ConvertingToggleStrongStr`, `ConvertingToggleStrikethroughStr`), потом блоки кода (`ConvertingBlockCodeStr`, `ConvertingCodeStr`), и в конце – специальные символы (`ConvertingAngleBracketsStr`, `RemoveBackslashCharacters`). Порядок важен, чтобы, например, не превратить `**` внутри блока кода в `<strong>`.
4.  Результат этой цепочки – строка, готовая к отображению в HTML-подобном формате – записывается в поля `Action`, `Expected`, `TestData` нашего объекта `Step`.

Такой же подход с вызовом `Utils` используется и в `TestCaseService` для поля `Description` тест-кейса.

## Заглянем под капот: Как работают утилиты?

В основе большинства методов `Utils` лежит использование **регулярных выражений (Regular Expressions, или Regex)**. Регулярное выражение – это шаблон, который описывает определенную последовательность символов. С помощью `Regex` можно:

*   Найти все места в тексте, которые соответствуют шаблону.
*   Заменить найденные фрагменты на что-то другое.
*   Извлечь части найденного фрагмента.

**Пример 1: Преобразование жирного текста (`ConvertingToggleStrongStr`)**

1.  **Вход:** Строка, например, `"Это **очень** важный текст."`
2.  **Шаблон Regex:** `\*\*(.*?)\*\*`
    *   `\*\*`: Ищет два символа `*` (их нужно экранировать с помощью `\`, так как `*` – специальный символ в Regex).
    *   `(.*?)`: Это "захватывающая группа". `.` означает любой символ, `*` означает ноль или больше раз, `?` делает поиск "ленивым" (останавливается на первом же совпадении `**`). Скобки `()` говорят: "Запомни то, что нашлось внутри".
    *   `\*\*`: Ищет еще два символа `*`.
3.  **Поиск:** Regex находит в строке `"**очень**"`. Группа `(.*?)` захватывает слово `"очень"`.
4.  **Замена:** Метод заменяет всю найденную часть (`"**очень**"`) на строку `<strong>{захваченная_группа}</strong>`, то есть на `"<strong>очень</strong>"`.
5.  **Выход:** `"Это <strong>очень</strong> важный текст."`

**Пример 2: Извлечение вложений (`ExtractAttachments`)**

1.  **Вход:** `"Картинка: ![Логотип](https://site.com/logo.png)"`
2.  **Шаблон Regex 1:** `!\[[^\[\]]*\]\([^()\s]*\)` (Находит `![любой текст]\(URL без пробелов\)`)
3.  **Поиск 1:** Находит `![Логотип](https://site.com/logo.png)`
4.  **Шаблон Regex 2:** `\(([^()\s]+)\)` (Находит текст внутри `()` без пробелов)
5.  **Поиск 2 (внутри результата Поиска 1):** Находит `(https://site.com/logo.png)` и захватывает `https://site.com/logo.png`.
6.  **Извлечение имени файла:** Из URL `https://site.com/logo.png` извлекается последняя часть – `logo.png`.
7.  **Замена:** В исходной строке `![Логотип](https://site.com/logo.png)` заменяется на `<<<logo.png>>>`.
8.  **Создание объекта:** Создается объект `QaseAttachment` с `Name = "logo.png"` и `Url = "https://site.com/logo.png"`.
9.  **Выход:** Возвращается объект `QaseDescriptionData` со строкой `"Картинка: <<<logo.png>>>"` и списком, содержащим созданный `QaseAttachment`.

**Визуализация цепочки преобразований (упрощенно):**

Представим, как `ConvertingStepDescription` обрабатывает строку `"**Ссылка:** [Qase](http://qase.io)\nКод: `print()`"`

```mermaid
graph LR
    A[Исходная строка: "**Ссылка:** [Qase](http://qase.io)\nКод: `print()`"] --> B{1. ConvertingFormatCharactersWithBlockCodeStr};
    B --> C{2. ConvertingFormatCharacters};
    C --> D["Строка:\n<p>**Ссылка:** [Qase](http://qase.io)</p><p>Код: `print()`</p>"];
    D --> E{3. ConvertingHyperlinks};
    E --> F["Строка:\n<p>**Ссылка:** <a href='http://qase.io'>Qase</a></p><p>Код: `print()`</p>"];
    F --> G{4. ConvertingToggleStrongStr};
    G --> H["Строка:\n<p><strong>Ссылка:</strong> <a href='http://qase.io'>Qase</a></p><p>Код: `print()`</p>"];
    H --(Пропускает, нет ```...)--> I{5. ConvertingBlockCodeStr};
    I --> J{6. ConvertingCodeStr};
    J --> K["Строка:\n<p><strong>Ссылка:</strong> <a href='http://qase.io'>Qase</a></p><p>Код: <code class='tiptap-inline-code'>print()</code></p>"];
    K --(Пропускает, нет ~~...)--> L{7. ConvertingToggleStrikethroughStr};
    L --(Пропускает, нет \<...)--> M{8. ConvertingAngleBracketsStr};
    M --(Пропускает, нет лишних \...)--> N{9. RemoveBackslashCharacters};
    N --> Z[Результат: Готово к использованию];

```

Эта диаграмма показывает, как текст последовательно проходит через разные методы `Utils`, и каждый метод вносит свои изменения, подготавливая строку к итоговому формату.

## Посмотрим на код

Класс `Utils` находится в файле `Services/Utils.cs`.

**1. Статический класс:**
Как мы уже говорили, класс объявлен как `static`, поэтому его методы вызываются напрямую.

```csharp
// Файл: Services/Utils.cs (Начало)
using System.Text.RegularExpressions;
using QaseExporter.Models;

namespace QaseExporter.Services;

public static class Utils // Ключевое слово static
{
    // Приватные константы с шаблонами Regex
    private const string ImgPattern = @"!\[[^\[\]]*\]\([^()\s]*\)";
    private const string UrlPattern = @"\(([^()\s]+)\)";
    private const string ToggleStrongStrPattern = @"\*\*(.*?)\*\*";
    // ... и другие шаблоны ...

    // ... методы ...
}
```

**2. Пример: `ConvertingToggleStrongStr`**
Метод использует `Regex.Matches` для поиска всех совпадений и цикл `foreach` для их замены.

```csharp
// Файл: Services/Utils.cs (Метод ConvertingToggleStrongStr)
public static string ConvertingToggleStrongStr(string description)
{
    // Находим все совпадения с шаблоном **текст**
    var matches = GetAllMatchesByPattern(description, ToggleStrongStrPattern);

    if (matches.Count == 0) // Если ничего не найдено, возвращаем как есть
    {
        return description;
    }

    // Проходим по каждому найденному совпадению
    foreach (Match match in matches)
    {
        // Удаляем символы ** по краям найденного текста (вспомогательный метод)
        var matchWithoutToggleStrongFormat = RemoveToggleStrongCharacters(match.Value);
        // Заменяем исходное совпадение (например, "**текст**") на HTML-версию
        description = description.Replace(match.Value, $"<strong>{matchWithoutToggleStrongFormat}</strong>");
    }

    return description; // Возвращаем измененную строку
}

// Вспомогательный метод для удаления ** по краям
public static string RemoveToggleStrongCharacters(string description)
{
    // Шаблон для поиска "**"
    const string ToggleStrongCharacterPattern = @"\*\*";
    // Заменяем все "**" на пустую строку ""
    return RemoveCharactersFromDescriptionByPattern(description, ToggleStrongCharacterPattern);
}

// Общий метод для удаления символов по шаблону
private static string RemoveCharactersFromDescriptionByPattern(string description, string pattern)
{
    if (string.IsNullOrEmpty(description)) return string.Empty;
    var regex = new Regex(pattern);
    return regex.Replace(description, ""); // Замена на ""
}

// Общий метод для поиска всех совпадений
private static List<Match> GetAllMatchesByPattern(string? description, string pattern)
{
    if (string.IsNullOrEmpty(description)) return new List<Match>();
    var regex = new Regex(pattern);
    return regex.Matches(description).ToList(); // Возвращает список всех найденных совпадений
}
```

**3. Пример: `ExtractAttachments`**
Этот метод немного сложнее: он ищет совпадения, извлекает из них URL и имя, модифицирует исходную строку и собирает список объектов `QaseAttachment`.

```csharp
// Файл: Services/Utils.cs (Метод ExtractAttachments)
public static QaseDescriptionData ExtractAttachments(string? description)
{
    // Создаем объект для хранения результата
    var data = new QaseDescriptionData
    {
        Description = description ?? string.Empty, // Исходное описание (или пустое)
        Attachments = new List<QaseAttachment>()   // Пустой список для вложений
    };

    // Ищем все совпадения ![...](...)
    var matches = GetAllMatchesByPattern(description, ImgPattern);

    if (matches.Count == 0) // Если нет картинок, возвращаем исходные данные
    {
        return data;
    }

    // Обрабатываем каждое найденное вложение
    foreach (Match match in matches)
    {
        // Используем Regex для извлечения URL из скобок (...)
        var urlRegex = new Regex(UrlPattern);
        var urlMatch = urlRegex.Match(match.Value);

        if (!urlMatch.Success) continue; // Если URL не найден, пропускаем

        var url = urlMatch.Groups[1].Value; // Получаем сам URL
        var fileName = url.Split('/').LastOrDefault() ?? $"attachment_{Guid.NewGuid()}"; // Извлекаем имя файла из URL

        // Заменяем ![...](...) в тексте на <<<имя_файла>>>
        data.Description = data.Description!.Replace(match.Value, $"<<<{fileName}>>>");

        // Добавляем информацию о вложении в список
        data.Attachments.Add(new QaseAttachment
        {
            Name = fileName,
            Url = url
        });
    }

    return data; // Возвращаем объект с измененным описанием и списком вложений
}
```

Большинство других методов в `Utils` работают по схожему принципу: находят текст по шаблону Regex и заменяют его на нужный HTML-эквивалент или просто удаляют ненужные символы.

## Заключение

Вспомогательные утилиты в статическом классе `Utils` играют роль "швейцарского ножа" для обработки текста в `QaseExporter`. Они предоставляют набор простых, но мощных инструментов, основанных на регулярных выражениях, для:

*   Преобразования разметки Qase (похожей на Markdown) в HTML-подобный формат.
*   Извлечения информации о вложениях из текста.
*   Очистки текста от нежелательных символов.

Эти утилиты используются различными сервисами ([StepService](04_сервис_обработки_тест_кейсов_.md), [TestCaseService](04_сервис_обработки_тест_кейсов_.md)) для подготовки текстовых данных перед их сохранением [Сервисом Записи Результатов](07_сервис_записи_результатов_.md). Понимание их работы помогает увидеть, как `QaseExporter` адаптирует контент из Qase для целевой системы.

На этом мы завершаем обзор основных компонентов `QaseExporter`. Мы рассмотрели весь путь: от точки входа и настройки приложения, через получение данных с помощью клиента Qase API, их обработку различными сервисами (тест-кейсы, атрибуты, вложения, шаги) и до финальной записи результатов с помощью сервиса записи и вспомогательных утилит для текста. Надеемся, это руководство помогло вам понять внутреннее устройство `QaseExporter`!

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)