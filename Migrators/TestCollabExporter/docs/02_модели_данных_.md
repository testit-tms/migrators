# Chapter 2: Модели данных


В [предыдущей главе](01_сервис_экспорта_.md) мы познакомились с [Сервисом Экспорта](01_сервис_экспорта_.md), главным координатором нашего процесса переноса данных. Мы узнали, что он управляет другими сервисами, чтобы получить данные из TestCollab, преобразовать их и сохранить. Но в каком виде существуют эти данные внутри программы? Как мы можем быть уверены, что все части приложения "понимают" структуру тест-кейса или секции одинаково?

Именно здесь на сцену выходят **Модели Данных**.

## Какую проблему они решают?

Представьте, что вы строите дом из конструктора LEGO. У вас есть инструкция (алгоритм работы сервисов) и множество деталей разной формы и размера (данные). Чтобы собрать дом правильно, вам нужны не просто куча деталей, а четкое понимание, *какая* деталь для чего предназначена: это кубик 2x4, это окно, это дверь.

В программировании похожая ситуация. Когда [Клиент API TestCollab](03_клиент_api_testcollab_.md) получает информацию из TestCollab, она приходит в определенном формате. А [Сервис записи данных (JsonWriter)](06_сервис_записи_данных__jsonwriter__.md) должен сохранить ее в *другом* формате, подходящем для JSON-файлов. Чтобы этот переход был гладким и без ошибок, нам нужны "чертежи" или "шаблоны" для данных на каждом этапе.

**Модели данных** — это и есть такие чертежи. Они представляют собой специальные классы в C#, которые точно описывают структуру каждого типа информации, с которой работает приложение. Они гарантируют, что и сервис, получающий данные, и сервис, их преобразующий, и сервис, их записывающий, "знают", что, например, у тест-кейса есть название (текст), приоритет (текст), шаги (список) и так далее.

## Ключевые типы моделей в `TestCollabExporter`

В нашем проекте используется несколько категорий моделей данных:

1.  **Модели данных из TestCollab:** Эти классы описывают структуру данных в том виде, в каком они приходят *из* TestCollab API. Они находятся в папке `Models` внутри проекта `TestCollabExporter`.
    *   Примеры: `TestCollabTestCase`, `TestCollabSuite`, `TestCollabCustomField`.
    *   **Аналогия:** Это как "сырые ингредиенты", полученные от поставщика (TestCollab). У них своя упаковка и состав.

2.  **Модели целевого формата:** Эти классы описывают структуру данных в том виде, в каком они должны быть сохранены в *конечных* JSON-файлах. Эти модели импортируются из отдельного проекта под названием `Models` (обратите внимание, он подключен в файле `TestCollabExporter.csproj`).
    *   Примеры: `TestCase`, `Section`, `Attribute`, `SharedStep`, `Root` (основная структура проекта).
    *   **Аналогия:** Это "чертеж готового блюда" из нашей кулинарной книги – то, что мы хотим получить в итоге.

3.  **Вспомогательные модели:** Эти классы используются *в процессе* конвертации для хранения промежуточных результатов или сопоставлений (например, какой ID секции в TestCollab соответствует какому новому ID в нашей системе). Они также находятся в папке `Models` внутри проекта `TestCollabExporter`.
    *   Примеры: `SectionData`, `AttributeData`, `SharedStepData`.
    *   **Аналогия:** Это "миски для смешивания" или "заметки повара", которые помогают в процессе приготовления, но не являются ни сырым ингредиентом, ни финальным блюдом.

## Как это используется?

Модели данных сами по себе не выполняют действий. Они служат шаблонами, которые используют другие сервисы.

*   **[Клиент API TestCollab](03_клиент_api_testcollab_.md):** Когда клиент получает ответ от TestCollab (обычно в формате JSON), он использует модели типа `TestCollab...` (например, `TestCollabTestCase`), чтобы "распаковать" этот JSON в удобные C#-объекты.
*   **Сервисы Конвертации ([Сервис конвертации тест-кейсов](04_сервис_конвертации_тест_кейсов_.md), [Сервис конвертации секций](05_сервис_конвертации_секций_.md)):** Эти сервисы принимают на вход объекты моделей `TestCollab...`, обрабатывают их (возможно, используя вспомогательные модели для хранения промежуточных данных и связей) и создают объекты *целевых* моделей (`TestCase`, `Section`).
*   **[Сервис записи данных (JsonWriter)](06_сервис_записи_данных__jsonwriter__.md):** Этот сервис берет готовые объекты целевых моделей (`TestCase`, `Section`, `Root`) и преобразует их в строки JSON для записи в файлы.

**Пример: Преобразование Тест-Кейса**

1.  **Вход (из TestCollab API):** Данные, соответствующие модели `TestCollabTestCase`.
    ```csharp
    // File: Models\TestCollabTestCase.cs (упрощенно)
    namespace TestCollabExporter.Models;

    public class TestCollabTestCase
    {
        [JsonPropertyName("title")] // Как поле называется в JSON от TestCollab
        public string Title { get; set; } // Название должно быть строкой

        [JsonPropertyName("priority")]
        public string Priority { get; set; } // Приоритет - строка

        [JsonPropertyName("steps")]
        public List<Steps> Steps { get; set; } // Шаги - это список объектов Steps

        // ... другие поля из TestCollab ...
    }

    public class Steps // Модель для шага внутри TestCollabTestCase
    {
        [JsonPropertyName("step")]
        public string Step { get; set; } // Описание шага

        [JsonPropertyName("expected_result")]
        public string ExpectedResult { get; set; } // Ожидаемый результат
    }
    ```
    *   **Пояснение:** Этот код определяет класс `TestCollabTestCase`. Атрибуты `[JsonPropertyName(...)]` помогают правильно связать поля класса с полями в JSON, получаемом от TestCollab. Мы видим, что у тест-кейса есть `Title` (название), `Priority` (приоритет) и `Steps` (шаги), где каждый шаг тоже имеет свою структуру (`Steps`).

2.  **Процесс (в [Сервисе конвертации тест-кейсов](04_сервис_конвертации_тест_кейсов_.md)):** Сервис берет объект `TestCollabTestCase` и создает новый объект `TestCase` (из целевой модели). При этом он может выполнять преобразования: например, сконвертировать текстовый приоритет из TestCollab ("Высокий") в какой-то другой формат или ID, или связать шаги тест-кейса с общими шагами, используя вспомогательные модели.

3.  **Выход (для записи в JSON):** Данные, соответствующие модели `TestCase` из проекта `Models`.
    ```csharp
    // Из проекта Models (упрощенно)
    namespace Models;

    public class TestCase
    {
        public Guid Id { get; set; } // Уникальный идентификатор для нашей системы
        public required string Name { get; set; } // Имя тест-кейса (вероятно, из Title)
        public required List<Step> Steps { get; set; } // Список шагов (возможно, преобразованных)
        public Guid SectionId { get; set; } // ID секции, к которой он принадлежит
        // ... другие поля целевого формата ...
    }

    public class Step
    {
        public string Action { get; set; } // Действие (вероятно, из Step)
        public string ExpectedResult { get; set; } // Ожидаемый результат
        public Guid? SharedStepId { get; set; } // Ссылка на общий шаг, если используется
    }
    ```
    *   **Пояснение:** Это структура целевого `TestCase`. Обратите внимание: здесь есть `Id` типа `Guid` (уникальный идентификатор, которого не было напрямую в `TestCollabTestCase`), `SectionId` для связи с секцией, а шаги (`Step`) могут содержать ссылку на `SharedStepId`. Имена полей (`Name`, `Action`) могут отличаться от исходных (`Title`, `Step`). Модели данных четко определяют эту *новую* структуру.

**Пример вспомогательной модели:**

Вспомогательные модели часто содержат не только списки объектов, но и словари (Map) для быстрого поиска соответствий.

```csharp
// File: Models\SectionData.cs
using Models; // Используем целевую модель Section из проекта Models

namespace TestCollabExporter.Models;

public class SectionData
{
    // Список уже сконвертированных секций в целевом формате
    public List<Section> Sections { get; set; }

    // Словарь для быстрого поиска:
    // Ключ: ID секции из TestCollab (число)
    // Значение: Новый ID секции в нашей системе (Guid)
    public Dictionary<int, Guid> SectionMap { get; set; }

    // Специальная секция для общих шагов
    public Section SharedStepSection { get; set; }
}
```
*   **Пояснение:** Модель `SectionData` хранит результат конвертации секций (`List<Section> Sections`) и, что очень важно, `SectionMap`. Этот словарь позволяет [Сервису конвертации тест-кейсов](04_сервис_конвертации_тест_кейсов_.md) быстро узнать, какой `Guid` соответствует исходному числовому `Id` родительской секции тест-кейса из TestCollab, чтобы правильно установить поле `SectionId` в целевой модели `TestCase`.

## Зачем нужны отдельные модели?

Может показаться избыточным иметь разные наборы моделей. Почему не использовать один универсальный?

*   **Разные источники и цели:** Структура данных в TestCollab API продиктована разработчиками TestCollab. Структура целевых JSON-файлов определяется требованиями системы, куда будут импортироваться данные (или просто желаемым форматом хранения). Они редко совпадают.
*   **Гибкость:** Разделение позволяет менять одно независимо от другого. Если TestCollab изменит свое API (и нам придется обновить модели `TestCollab...`), это не обязательно затронет формат наших конечных JSON-файлов (и модели `TestCase`, `Section` и т.д.). И наоборот.
*   **Чистота кода:** Каждый сервис работает с той структурой данных, которая ему наиболее удобна на данном этапе. Клиенту API удобно работать с моделями, точно отражающими ответ API. Сервису записи удобно работать с моделями, точно описывающими целевой JSON. Сервисам конвертации нужны обе структуры и вспомогательные данные для перехода между ними.

## Визуализация потока данных через модели

```mermaid
graph LR
    A[Данные из TestCollab API] -- JSON --> B(Клиент API);
    B -- Создает объекты --> C(Модели TestCollab...);
    subgraph Сервисы Конвертации
        D(Конвертер Секций)
        E(Конвертер Тест-Кейсов)
        F(и т.д.)
    end
    C -- Используются --> Сервисы Конвертации;
    G(Вспомогательные Модели: SectionData, AttributeData...) -- Используются --> Сервисы Конвертации;
    Сервисы Конвертации -- Создают объекты --> H(Целевые Модели: Section, TestCase...);
    H -- Используются --> I(Сервис Записи JsonWriter);
    I -- Формирует --> J[JSON Файлы];

    classDef model fill:#f9f,stroke:#333,stroke-width:2px;
    class C,G,H model;

```
*   **Пояснение:** Диаграмма показывает, как данные "перетекают" из одного формата в другой с помощью моделей. Сначала JSON от API превращается в объекты моделей `TestCollab...`. Затем сервисы конвертации используют эти объекты (и вспомогательные модели) для создания объектов целевых моделей (`Section`, `TestCase`). Наконец, сервис записи использует целевые модели для генерации конечных JSON-файлов. Модели данных выступают как контейнеры и шаблоны на каждом шаге этого потока.

## Заключение

Модели данных — это фундаментальный строительный блок `TestCollabExporter`. Они обеспечивают:

*   **Структуру:** Четкое определение того, из чего состоят данные (поля, типы данных).
*   **Согласованность:** Гарантию того, что все части приложения "понимают" данные одинаково.
*   **Предсказуемость:** Возможность точно знать, какие данные ожидаются на входе и выходе каждого сервиса.

Они как чертежи в строительстве или рецепты в кулинарии — необходимы для создания качественного и работающего конечного продукта. Понимание того, как устроены эти модели, помогает разобраться в том, как данные преобразуются во время экспорта.

Теперь, когда мы знаем, *в каком виде* хранятся данные из TestCollab внутри приложения, давайте подробнее рассмотрим, *как* мы их получаем. В следующей главе мы погрузимся в работу [Клиент API TestCollab](03_клиент_api_testcollab_.md).

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)